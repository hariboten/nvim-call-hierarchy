了解しました。Neovim用のCall Hierarchy UIプラグインのコーディングエージェント向け設計書（Markdown形式、図付き、コード例なし）を作成します。

この設計書では、仕様・要件・UI構造・モジュール分割・パネル動作などを明示し、エージェントが正確に実装を開始できるように構成します。

完成次第お知らせしますので、しばらくお待ちください。


# 概要

Neovim上で**呼び出し階層 (Call Hierarchy)** を視覚的に表示・操作するためのUIプラグインです。対象シンボル（関数やメソッド）の呼び出し元および呼び出し先をツリー構造で表示し、インタラクティブに展開・折り畳みしながらコードの呼び出し関係を辿ることができます。VS CodeやIntelliJ系IDEに備わる「呼び出し階層」機能に相当し、Neovim組み込みLSPではQuickfixリスト表示に留まるコールツリーを、専用パネルで階層的に閲覧・ナビゲーションできるようにします。本プラグインはNeovim 0.10.0以降の組み込みLSPクライアントと連携し、Java・Rust・TypeScript（Angular含む）・Luaなど主要言語のLanguage Serverが提供する呼び出し階層機能を活用します。

# 目的と背景

本プラグインの目的は、**Neovimにおけるコードリーディング効率の向上**です。従来、Neovim標準の`:lua vim.lsp.buf.incoming_calls()`等で呼び出し関係を調べるとQuickfixウィンドウにフラットなリストが表示されるだけで、深い呼び出し連鎖を視覚化・追跡するのが困難でした。一方、IDEでは関数の呼び出し元・呼び出し先をツリー形式で辿ることができ、コードの影響範囲や参照関係を直感的に把握できます。そこで本プラグインでは、Neovim上に軽量な**コールツリー専用UI**を提供し、関数の「呼び出し元の呼び出し元…」や「呼び出し先の呼び出し先…」と再帰的に関係を追跡できるようにします。これにより大規模プロジェクトでも関数の利用箇所や挙動を素早く把握し、リファクタリングやバグ追跡の効率を高めることが期待できます。また、本プラグインは既存のLSP機能を活用しているため、特定言語に依存せず複数言語で同一の操作体験を提供することも目的としています。

# 想定ユーザー

* **Neovimを利用している開発者**：特にJavaやRust、TypeScript/Angular、Luaといった言語でLSPを使いながら開発しているプログラマー。
* **大規模コードベースのメンテナ**：関数の呼び出し関係を素早く追跡し、影響範囲の分析やリファクタリングを行いたいユーザー。
* **IDEライクなナビゲーションを求めるユーザー**：VS Codeや他のIDEの呼び出し階層機能に慣れており、Neovim上でも類似のコードナビゲーション機能を求める開発者。
* **プラグイン開発者/先進ユーザー**：Neovimの拡張やLSP機能に関心があり、呼び出し階層UIのカスタマイズや統合（例：他プラグインとの連携、独自キーマップ設定など）を行う可能性のあるユーザー。

# 機能要件

本プラグインが提供する主な機能と要件は以下の通りです。

* **呼び出し階層ツリー表示**: シンボル（関数・メソッド）を選択すると、その呼び出し元または呼び出し先をツリー構造で表示します。ツリーは画面下部の水平分割パネルに表示され、ノードは「`アイコン  関数名 — クラス名`」の書式でラベルを示します（クラス名は該当する場合のみ。非OOP言語ではモジュール名やファイル名等）。各ノード左には言語別のアイコン（例：関数シンボルのマーク）を表示し、`nvim-web-devicons`ライブラリを用いて視認性を向上します。

* **ノード展開・折り畳み**: ツリー上のノードをキー操作で再帰的に展開・折り畳みできます。ユーザーが\*\*`o`キー\*\*を押下すると選択ノードの子ノード（呼び出し階層の次レベル）を取得・表示し、再度押下で折り畳んで非表示にします。これにより、呼び出し元のさらに呼び出し元…といった深い層も必要に応じて辿ることが可能です。ノード展開時、まだ子情報を取得していない場合はバックグラウンドで該当シンボルの呼び出し情報をLSP経由で取得します。既に取得済みの場合はキャッシュされたデータで即座に展開し、折り畳み・再展開のレスポンスを高速化します。

* **ジャンプ操作**: ツリー上で関数ノードを選択し、**`e`キー**を押下すると、そのシンボルの定義箇所（または呼び出し箇所）へエディタをジャンプ（カーソル移動）します。ジャンプ先は新たなバッファまたはウィンドウに表示され（ユーザ設定によっては現在ウィンドウ、垂直分割、タブなど選択可）、ユーザーはソースコードを直接閲覧・編集できます。ジャンプ後も呼び出し階層パネルは開いたまま維持され、コード閲覧とツリー参照を行き来できるようにします。ジャンプ機能により、ツリーで見つけた関数を素早くコード上で確認・編集でき、ナビゲーション効率が向上します。

* **リフレッシュ**: **`r`キー**で現在表示中の呼び出し階層ツリーをリフレッシュ（更新）できます。これにより、例えばソースコードを編集して呼び出し関係が変化した場合や、LSPサーバ側でキャッシュが更新された場合に、最新の情報でツリーを再構築します。リフレッシュ操作時は現在のルートシンボルについて再度LSPに呼び出し階層クエリを発行し、新しい結果でツリーを置き換えます。ユーザーに明示的な更新操作を提供することで、常に正確な情報に基づいたナビゲーションが可能になります。

* **フィルタ機能（テストコード除外）**: **デフォルトでテストコードをツリーから除外**するフィルタが有効になります。ユニットテストやSpecファイルなど、名前やパスに`test`や`spec`が含まれるファイル内の関数呼び出し、およびテスト用に命名された関数（例：`*Test`や`test*`で始まる関数など）はツリー表示から省略します。これにより、開発者が本番コードの呼び出し関係に集中でき、ノイズとなりがちなテスト関連の呼び出しをデフォルトで隠すことができます。フィルタは設定でON/OFF切替が可能で、必要に応じてテストコードも含めて解析できる柔軟性を提供します。

* **履歴管理**: 呼び出し階層のクエリ履歴を保持し、**最大20件**までスタックします。ユーザーが異なるシンボルの呼び出し階層を次々と調査した場合でも、過去のツリーを履歴として遡って再表示できます。**`h`キー**で直前に表示していた呼び出しツリーに戻り、**`l`キー**で進む（戻った後に再度進む）ことができます。履歴機能により、一度閉じた階層や別の関数を調べた後でも容易に以前の結果に立ち戻れるため、複数の関数の関係を比較検討する際に役立ちます。履歴は20件を超えると古いものから順に破棄されます。

* **対応言語**: 対象言語として**Java, Rust, TypeScript (Angularフレームワーク含む), Lua**を公式サポートします。これら言語のそれぞれで動作するLanguage Server（例：Java: `jdtls`, Rust: `rust-analyzer`, TypeScript/Angular: `tsserver`や`Angular LS`, Lua: `lua-language-server`など）が実装する呼び出し階層機能（LSPプロトコルの`textDocument/prepareCallHierarchy`および`callHierarchy/incomingCalls`・`outgoingCalls`リクエスト）に対応し、統一的なツリーUIを提供します。各言語特有のシンボル表現（例えばRustのトレイト実装やAngularのコンポーネント等）にも対応できるよう、可能な限りLSPから提供される情報を汎用的に処理します。将来的に他言語（例えばC/C++やPythonなど）の呼び出し階層にもLSP経由で対応可能ですが、本設計書では上記5言語を範囲とします。

* **UI操作とキーバインド**: 主要な操作にはデフォルトのキーバインドが割り当てられています（ノーマルモードで有効）。ユーザーは必要に応じてこれらをカスタマイズ可能ですが、デフォルトは以下の通りです。

  * **`o`** : ノードの展開/折り畳み（子呼び出しの表示・非表示切替）
  * **`e`** : 選択ノードの定義箇所へジャンプ（エディタで開く）
  * **`r`** : 呼び出し階層ツリーのリフレッシュ（再取得）
  * **`h`** : 履歴で前の呼び出しツリーを表示（バック）
  * **`l`** : 履歴で次の呼び出しツリーを表示（フォワード）
  * **`q`** : 呼び出し階層パネルを閉じる

  これら以外に、ツリー内の移動は通常のVim操作（**`j/k`**などカーソル移動）で行います。必要に応じて**Enterキー**でも`e`と同様のジャンプ操作を行えるようエイリアスを設定します（デフォルトでは`e`キーに割り当て）。ショートカットは直感的に配置しており、例えば「**o**pen/close（開く/閉じる）」で`o`、「**e**dit（編集/ジャンプ）」で`e`、「**r**efresh」で`r`と覚えやすくしています。

# 非機能要件

本プラグインの品質面・制約に関する要件です。

* **性能**: 初回の呼び出し階層ツリー表示はユーザー操作から**300ms以内**に完了することを目標とします。つまり、ユーザーがコマンド実行またはキープレスしてから、LSPサーバからの応答を受けツリーを描画し終えるまでを体感的に待たせない程度（0.3秒以内）に抑えます。ノードの展開・折り畳みといった後続操作は**20ms以内**（即座）の応答性を確保します。これにより、深いツリーを連続して展開する場合でもラグを感じない操作性を実現します。性能達成のために、非同期処理やキャッシュを適切に用いてLSP応答待ちによるブロッキングを回避します。また、LuaJIT上で効率良く動作するよう最適化し、不要な再計算や描画を抑制します。

* **キャッシュ**: 一度取得した呼び出し階層データ（特にノードの子リスト）は、同一セッション中はキャッシュとして保持します。ユーザーが同じ関数の呼び出し階層を再度開いた際や、一度展開したノードを再展開する際には、可能な限り再クエリせずキャッシュデータを利用して表示します。これにより、既出のノード展開における高速なレスポンス（≦20ms）を実現します。ただし、リフレッシュ操作が行われた場合やソースコードに変更があった場合にはキャッシュを無効化し、最新の情報を取得します。キャッシュサイズは過度に大きくならないよう管理し、不要になったデータ（履歴からも削除された古いツリー等）は適宜破棄します。

* **互換性**: Neovim **v0.10.0以降**で動作することを保証します。それ以前のバージョンでは組み込みLSP機能やUI APIが不足する可能性があるため対象外とします。また、依存プラグイン・ライブラリとして以下を利用します。

  * **plenary.nvim** – Luaユーティリティライブラリ。ファイル操作やAsync処理、テーブル操作などで便利関数を使用します。
  * **nvim-web-devicons** – ファイルタイプやシンボルに対応するアイコン描画用ライブラリ。ツリー中のアイコン表示に使用します。
    これら依存はNeovim標準機能ではないため、ユーザーには事前インストールが必要です。本プラグインはインストール時にこれらが存在するかチェックし、足りなければロードエラーを通知します。対応OSはNeovimが動作する主要OS（Linux, Windows, macOS）で特にOS依存部分はありません。LSPサーバはユーザー側で別途設定・インストールされていることを前提とし、本プラグイン側では特定のLSP実装に依存しない抽象的なやり取りを行います。

* **拡張性・他プラグインとの協調**: 本プラグインは単機能志向でありつつ、将来的な拡張にも耐える設計とします。他のプラグイン（例：シンボルアウトライン表示やファジーファインダ等）とのUI統合を妨げないよう、パネル表示のレイアウトやキーマップはカスタマイズ可能です。また`lua`スクリプト経由で公開API（関数）を提供し、外部から呼び出し階層ツリーを開く、閉じる、更新する、といった操作ができるようにします。内部実装はモジュール化し、例えば将来履歴数を増やす、異なるフィルタルールを追加するといった変更にも対応しやすい構造を目指します。ログ出力やデバッグモードも用意し、ユーザーや開発者が問題を特定しやすいようにします。

# システム構成

本プラグインの内部モジュール構造と役割を示します。プラグインはLuaで実装され、主に**UI表示**, **LSP通信**, **データ管理**, **履歴管理**のモジュールに分割されます。それぞれの責務と連携は以下の通りです。

&#x20;*プラグイン内部のモジュール構成と、Neovim/LSPとの連携関係。青色の箱が本プラグイン内モジュール、灰色が外部システム。実線矢印は主要な操作フロー、点線矢印は補助的なデータフローや依存関係を表す。*

* **UIパネル管理モジュール**: 呼び出し階層ツリーの表示領域（下部分割ウィンドウ）と描画ロジックを担当します。ツリー用バッファを作成し、ノード情報に基づいてテキストやアイコンを描画します。また当該バッファにローカルマッピングを設定し、ユーザーのキー入力（`o`, `e`, `r`, `h`, `l`, `q`など）に応じて適切なアクションをトリガーします。具体的には、`o`押下時に選択ノードの展開要求をデータ管理モジュールに通知し、返ってきた子ノード情報でバッファを書き換えます。`e`押下時にはジャンプ要求を受けて該当ノードのソース位置へ`vim.api.nvim_open_win`や`vim.cmd('edit <file>')`等でファイルを開きます。UIモジュールは**表示と入力受付**に専念し、データ取得やビジネスロジックは下位モジュールに委譲します。

* **LSPインターフェースモジュール**: Neovim組み込みのLSPクライアントを介してLanguage Serverへリクエストを送信・応答受信する役割を担います。ユーザーがツリーを開く際、まずこのモジュールが`textDocument/prepareCallHierarchy`でカーソル位置のシンボル情報を取得し、続けて`callHierarchy/incomingCalls`（または`outgoingCalls`）リクエストを発行して初期の呼び出しリストを取得します。ノード展開要求に対しても、このモジュールが該当シンボルIDを用いて再度`incomingCalls`/`outgoingCalls`をサーバに問い合わせ、その結果（子ノード一覧）を受け取ります。LSPからの応答データ（シンボル名、位置、親子関係など）はLuaテーブルにパースし、必要な情報だけを抽出してデータ管理モジュールに渡します。Neovimでは既定でこれらメソッドの呼び出し結果をQuickfixに表示するハンドラが設定されていますが、プラグイン読み込み時に`vim.lsp.handlers['callHierarchy/incomingCalls']`等を上書きして本モジュールの処理にフックすることで、標準挙動を差し替えています。LSPインターフェースは非同期に動作し、コールバックまたは`vim.wait`を用いてサーバ応答を受け取るとデータ管理へ通知します。

* **コールツリーデータ管理モジュール**: 呼び出し階層ツリーの内部データ構造を保持・操作する中核モジュールです。LSPインターフェースから渡された呼び出し関係データをツリー構造（ノードのネスト構造）として格納します。具体的には各ノードを表すLuaテーブル（フィールド：シンボル名、種別、位置、親ノード参照、子ノードリスト、展開状態フラグ等）を生成し、これらを木構造としてリンクします。UIモジュールからの要求（例：「ノードNを展開したい」）を受け取ると、当該ノードが子を持っているか確認し、未取得であればLSPインターフェース経由で取得を開始し、取得後にノードリストを自身のデータ構造に追加します。取得済みであれば即座に子ノードリストを返します。また、フィルタ機能も本モジュールで実装します。ツリー生成時やノード追加時に、対象ノードのファイルパスや名前をチェックし、テストコード判定に該当するものはツリーに含めない処理を行います（除外した旨をどこかUIに表示するかはオプション）。データ管理は**現在表示中のツリー状態**を一元的に管理し、履歴管理から過去ツリーを呼び出す際は内部状態を差し替えてUIに反映させます。さらにキャッシュとしての役割も持ち、取得済みデータを保持して再利用します。

* **履歴管理モジュール**: 呼び出し階層ツリーの履歴スタックを管理します。データ管理モジュールから呼び出される形で、新たにツリーが生成された際に直前のツリー状態をプッシュで保存します（最大20件まで）。保存内容にはルートシンボルやツリーのノード構造、各ノードの展開状態などを含めます。`h`/`l`キー操作時には、履歴スタック内の前後のツリーをデータ管理に返却し、現在表示中ツリーと差し替えさせます。これによりデータ管理およびUIは過去の状態を再現します。履歴管理はスタックのサイズ制限（20件）を超えた場合に古いエントリを破棄し、メモリ使用量を抑えるようにもします。プラグイン終了時やパネル閉鎖時には履歴をクリアします（またはセッション間で残す設定も将来的には検討可能）。履歴は単に過去ツリーを保存するだけでなく、ユーザーが戻る操作を行った際に現在のツリーを一時的にフォワードスタックに移すなど、ブラウザの戻る/進む操作に近い挙動を実現します。

* **設定・ユーティリティモジュール**: ユーザー設定の読み出しやプラグイン全体設定値（オプション）の管理、メッセージ表示などの補助機能を提供します。たとえばユーザーがinit.lua等で指定したアイコン文字やフィルタ設定値を保持し、他モジュールから参照可能にします。またplenary.nvimの機能をラップしてファイルパス文字列の正規化（テストコード判定に使用）、デバッグログ出力、非同期タイマー処理などを提供します。本プラグインは全体を通してLuaコードで構成され、Neovim APIとのインタラクションもこのモジュール経由で行う部分があります（例：パネル用ウィンドウの作成はUIモジュール内でもよいが、全体設定でウィンドウ幅/高さを変えられるよう本モジュールで一括管理する等）。

上記の各モジュールはシンプルなインターフェース関数を介して連携します。UI->データ管理への要求、データ管理->LSPモジュールへの要求、履歴->データ管理への提供など、明確な責務分担により可読性と保守性を確保します。この構成により、新たな機能追加（例えば双方向の呼び出し階層同時表示や別フォーマット出力）にも対応しやすい柔軟性を持たせています。

# UI構成

UIはNeovimのウィンドウ/バッファを用いて実現され、**画面下部に水平分割されたパネル**にコールツリーを表示します。以下にUIの構成要素と振る舞いを示します。

&#x20;*呼び出し階層ツリーUIの例（Go言語での関数呼び出しツリー表示）。左側のパネルにシンボルとその呼び出し関係がツリー表示され、右側にコードが表示されている。各ノードは関数名と所属構造体名が表示され、アイコンでネストが示されている。*

1. **ツリー表示パネル**: Neovim下部に配置される専用パネルです。既定では高さ10行程度のウィンドウとして開き、ファイルタイプ`callhierarchy`（仮）を持つバッファにツリーを描画します。パネル上部には対象シンボルやモード（Incoming/Outgoing）を示す見出し行を表示し、続いてツリー本体をインデント付きのテキストで一覧します。各ノード行は「アイコン  関数名 — クラス名」の形式で表示されます。アイコンは関数/メソッドの場合に特定のグリフ（例えば🔧やƒ記号など、deviconsが提供するもの）を表示し、クラス名は存在する場合に`— ClassName`として薄い色で表示します。ネストはインデント（スペースや「├─」「└─」等の線描画文字）で表現し、階層構造を視覚化します。ツリーの最下層ノードには別アイコン（例えば丸印）を用いて、それ以上子が無いことを示します。

2. **操作キーとステータス**: パネル内ではノーマルモードで前述のキー操作が利用できます。ユーザーがキーを押すと、その操作内容に応じて行頭のアイコンや行の表示が動的に更新されます（展開時に「▶」アイコンが「▼」に変化する等のフィードバック）。パネル下部のステータスラインには、現在の表示がIncoming(呼び出し元)かOutgoing(呼び出し先)か、現在選択中のノード位置（例：「3/15」）などを表示してコンテキストを示します。また、適用中のフィルタ（例：「\[Filter: Testコード除外]」）をオン時はステータスに表示し、ユーザーに現在フィルタが働いていることを明示します。

3. **Incoming/Outgoingモード**: ユーザーがあるシンボルについて「そのシンボルを呼び出している関数一覧（Incoming）」または「そのシンボルが呼び出している関数一覧（Outgoing）」のどちらかを選択して表示できます。基本動作として、**現在のカーソル下シンボルのIncoming Call Hierarchy**を開くコマンド（例：`:CallHierarchyIncoming`）と**Outgoing Call Hierarchy**を開くコマンド（例：`:CallHierarchyOutgoing`）を提供します。Incomingで開いた後にOutgoingに切り替えることも可能で、その場合パネル上部の見出しや内容を切り替えます（内部的にはLSPの別メソッドを呼び再取得）。初期実装ではIncomingをデフォルトとし、必要に応じOutgoingも見られるようにします。将来的にはパネル内でトグル（例えば`i/o`キーで切替）や両者同時表示（左右二分割でIncomingとOutgoingを並べる等）の拡張も考えられますが、本設計では単一方向表示とします。

4. **UIテーマと強調表示**: パネル表示は他のNeovim要素と同様にハイライトグループで色分け・装飾されます。関数名やクラス名にはLSPのシンボル種別に応じたハイライト（例：関数はIdentifier、クラス名はTypeなど）を適用し、現在アクティブなノード行にはCursorLine等で背景強調します。設定で現在開いているファイル内のシンボルと外部ファイルのシンボルで色を変えることもできます（例：同一モジュール内の呼び出しは緑、それ以外は通常色）。アイコン部分も必要に応じて色付けされます（deviconsが設定する色）。ツリーが長大になる場合にスクロールバーが表示されます。UI全体の配色・スタイルはユーザーのカラースキームに追従しつつ、見やすさを損なわないようデフォルト定義します。

5. **パネルの開閉とフォーカス**: パネルは通常、ユーザーがコマンドやキーバインドで呼び出した時に開き、**`q`キー**で明示的に閉じるまで表示されたままとなります。ユーザーがメインのコードウィンドウにフォーカスを戻して編集を再開した後も、パネルは非アクティブな状態で残ります（常に下部にツリーを表示したままにできる）。再度パネルにフォーカスを移す（例えば`<C-w>j`などウィンドウ移動）ことで、直前の状態から操作を続行できます。パネルを閉じると対応するバッファとウィンドウは破棄されますが、内部のツリーデータや履歴は保持されています。再度開いた時に新しいルートシンボルで表示する場合、古いデータは履歴へ送られます。なおパネルは通常は下部固定ですが、設定により右側縦分割表示などに変更可能とし、ユーザーの好みに合わせてレイアウトできる拡張性を持たせます（デフォルトは下split）。

# 処理フロー

ここでは、本プラグインの主要な処理フローについて、LSPとのやり取りおよび履歴管理の流れを中心に説明します。

**1. 呼び出し階層表示の開始:**  ユーザーが特定のシンボル上でコマンド（またはキーバインド）を実行すると処理が開始します。プラグインはまずNeovim組み込みLSPのAPIを通じて**対象シンボルを特定**します（必要なら`textDocument/prepareCallHierarchy`を呼び出し、シンボルIDや詳細を取得）。次に、指定方向（IncomingまたはOutgoing）の呼び出し階層リクエストをLSPサーバへ送信します。例えばIncomingの場合、`callHierarchy/incomingCalls`メソッドを発行し、そのシンボルを呼び出している呼び出し元関数の一覧を要求します。LSPサーバは解析を行い、結果として**CallHierarchyItem**の配列を返します（各要素が関数シンボルとその呼び出し箇所情報を含む）。

**2. 初期ツリー描画:** プラグインはLSPから受け取った呼び出し情報をもとに内部データ構造（ツリー）を構築します。次にUIパネルを開き、ツリーを描画します。ユーザーには対象シンボルをルートとした呼び出し階層ツリーが表示され、初期状態では第一階層（直接の呼び出し元/先）のみ展開された状態です。例えば、「関数A」をルートとしたIncomingツリーでは、「関数Aを呼び出している関数X, Y...」が最上位ノードとして一覧されます。各ノードはまだ子を展開していないため折り畳み状態（横に「▶」印などが表示）です。ユーザーはここから必要な操作を行っていきます。この初期描画までの一連の処理は非同期で行われ、ユーザー入力受付はLSP応答を待ってツリーが表示されてから開始します。初回表示完了後、性能要件で定めた300ms以内にユーザーが結果を確認できる想定です。

**3. ノード展開フロー:** ユーザーがツリー上のノード（例えば関数X）に移動し\*\*`o`キー**を押下すると、そのノードの子（関数Xによってさらに呼び出されている関数、または関数Xを呼び出している関数の一覧）を取得して表示する処理が走ります。プラグインはまず内部データ管理で**ノードXが既に子データを持っているか確認\*\*します。まだ取得していない場合、対応するLSPメソッド（Incomingツリー表示中でノードXが呼び出し元一覧なら、XをルートとしたincomingCalls）を呼び出し、LSPサーバに問い合わせます。サーバから応答が来ると（例えば関数Xを呼び出している関数の一覧）、その結果をパースしてノードXの子としてデータ構造に追加します。UIはノードXの行の下に新たな行を挿入し、関数Xの子ノード群をインデント付きで描画します。ユーザーから見るとツリーが「下に展開」され、`▶`が`▼`に変わります。子ノードには更に未展開のものが含まれる場合、同様の操作で深く辿って行けます。子の取得はキャッシュされるため、一度展開したXを閉じて再度`o`を押す場合、**キャッシュから即座に表示**し直し（目標20ms以内）、再度LSP問い合わせは発生しません。子が存在しない（LSP応答で空リスト）場合は、ノードXは葉ノードとみなしてアイコンを変更するか`▶`印を表示しないようにします。

**4. ジャンプと編集フロー:** ユーザーがツリー内の任意のノードで\*\*`e`キー\*\*（ジャンプ）を押下すると、該当シンボルの定義箇所または参照箇所へエディタがジャンプします。内部的にはノードが保持している`uri`（ファイルパス）と位置（行番号等）情報を取得し、Neovim APIでそのファイルを開いて指定位置にカーソルを移動します（デフォルトは現在のウィンドウでジャンプし、設定により vsplitやtabで開くことも可能）。ジャンプ後、ユーザーはコードを閲覧・編集できます。パネルは開いたままなので、必要に応じてツリーにフォーカスを戻し（ウィンドウ移動操作）、別のノードをさらに展開・ジャンプする、といった操作もできます。ジャンプ先のファイルで別の関数にカーソルを移動し、新たにその関数をルートとして呼び出し階層を開くことも可能です（その場合は現在のツリーを履歴に保存して新しいツリーに切り替わります）。

**5. リフレッシュフロー:** ユーザーが\*\*`r`キー\*\*を押下すると、現在表示中のツリーを再取得します。プラグインは内部データをクリアし（またはバックアップして履歴に保存し）、現在のルートシンボルに対して改めてLSPに呼び出し階層リクエストを送ります。応答を受けると新しいツリーを構築し直し、UIを更新します。この際、一時的にパネル上に「Refreshing...」のメッセージやスピナーアイコンを表示してユーザーに処理中であることを示す工夫も考えられます。結果が届けば速やかに表示を差し替えます。リフレッシュによって、例えば最新のコード変更で関数の呼び出し先が増減した場合にも正しい情報が得られます。性能に配慮し、リフレッシュ操作もできるだけ迅速（300ms程度以内）に完了するようLSP問い合わせ以外の処理を軽量にします。

**6. 複数回の階層表示と履歴登録:** ユーザーがあるシンボルAの呼び出し階層を見た後、別のシンボルBについて再度コールツリーを開く場合、現在のツリーを閉じずに他のファイルでコマンドを実行したり、またはパネル上でフォーカスを当てたノードに対して**フォーカス変更**（例えば将来的には`f`キーなどで選択ノードを新たなルートとしてツリーを開き直す操作も検討）することができます。いずれにせよ、新しいツリーを表示する直前に**履歴管理**へ現在のツリー状態を保存します。履歴管理モジュールはルートAのツリー（展開状態含む）をスタックにプッシュし、次にルートBのツリーを取得・表示します。ユーザーにはシームレスにツリーがBに切り替わり表示されます。この際パネルは再利用し、中身だけ差し替えます（見出しもBの情報に更新）。切り替えが行われたことをどこか（例えばステータスライン）に「←A」「B→」のように示し、`h/l`で戻れることを視覚的にフィードバックする案もあります。

**7. 履歴ナビゲーションフロー:** 履歴に複数のツリーが蓄積された状態で、ユーザーが\*\*`h`キー**を押下すると「直前に表示していた呼び出し階層」に戻ります。内部的には履歴スタックから直近のエントリをポップし、現在のツリーをフォワードスタックに退避させ（進む操作に備える）、取り出した過去ツリーをデータ管理に渡します。データ管理モジュールは現在のツリー構造をその過去状態に置き換え、UIに再描画を要求します。結果、ユーザーには以前見ていたツリーがその時の展開状態も含め復元されます。続けて**`l`キー\*\*を押下すれば先ほどのツリー（戻る前に見ていたもの）に進むことができます。これは履歴スタックで管理していたフォワード側からデータを取り出し、再度現在ツリーとして設定・表示する処理です。これら履歴の戻る・進む操作は連続で何度も可能です（最大20件まで遡り可）。履歴機能により、ユーザーは複数の関数の呼び出し階層を行き来しながら比較検討できます。例えば「関数Aと関数B、お互いにどこから呼ばれているか」を交互に確認するといった使い方が容易になります。なお、新規にツリーを表示した時点でフォワード側の履歴はクリアします（ブラウザの新規遷移時と同様）。

**8. パネル閉鎖と終了:** ユーザーが解析を終え\*\*`q`キー\*\*でパネルを閉じると、UIバッファ/ウィンドウは破棄されます。この際、現在表示中のツリー状態は履歴に残したままとするか、一緒にクリアするか設計選択があります。メモリ最適化のためには閉じた時点で履歴含めデータを全て解放するのが安全ですが、ユーザーが再度同じセッション中にパネルを開いた際に前回の状態から続行したいケースも考えられます。本プラグインではデフォルト挙動として、パネル閉鎖時も内部のデータ（履歴スタック含む）は保持し、次回開いた際に`h`キーで直前のツリーに戻れるようにします（一度Neovimを終了すればデータは消える）。パネル閉鎖操作では画面上のリソース解放のみ行い、データ管理・履歴管理モジュールは待機状態になります。ユーザーがNeovimを終了した時点で全データを解放します。必要に応じて`:qall`などエディタ終了時にも後処理は不要なので、特別な終了処理はありません。

以上が主な処理フローです。エラー処理として、例えばLSPサーバが呼び出し階層をサポートしていない場合や、結果が空だった場合にはパネルにメッセージ（「Call Hierarchy not supported for this language」あるいは「No calls found」等）を表示し、適切にユーザーに通知します。また、ネットワーク遅延などで応答が遅い場合にもタイムアウトを検出し、ユーザーに再試行を促すUI（メッセージや手動キャンセル方法）を用意します。これら例外パスも含めて、スムーズなインタラクションを提供することが求められます。

# 設定項目一覧

ユーザーが設定可能なオプション項目とその内容をまとめます。本プラグインでは`require('callhierarchy').setup{ ... }`の引数テーブルやグローバル変数を通じて以下の設定を行えます。

* **`enable_filter_tests`** (boolean) - テストコード除外フィルタを有効にするか。デフォルトは`true`（有効）。`false`にするとテストファイル内の関数もツリーに表示されます。
* **`history_limit`** (number) - 保存する履歴エントリ数の上限。デフォルト`20`。必要なら増減可能ですが、極端に増やすとメモリ使用量が増える点に注意。
* **`panel_height`** (number) - 呼び出し階層パネルの高さ（行数）。デフォルト`10`行。ユーザーの画面サイズや好みに応じて変更できます。
* **`panel_position`** (string) - パネル表示位置。デフォルトは`"bottom"`（下部水平分割）。将来的拡張で`"right"`（右側縦分割）等も指定可能にします。
* **`keymap_expand`**, **`keymap_jump`**, **`keymap_refresh`**, **`keymap_back`**, **`keymap_forward`**, **`keymap_close`** – 各操作に対するキーバインド設定。デフォルトでそれぞれ`"o"`, `"e"`, `"r"`, `"h"`, `"l"`, `"q"`が割り当て済み。ユーザーの他プラグインとの競合に応じてカスタマイズ可能。
* **`icons`** (table) - アイコン文字の設定。たとえば`{ expanded = "▼", collapsed = "▶", function = "ƒ", method = "m" }`のように、展開状態やシンボル種別ごとの表示アイコンを上書きできます。デフォルトではdeviconsとUnicode記号の組合せで適切に設定されています。
* **`highlight_groups`** (table) - ハイライトに使用するグループ名の設定。例えば`{ same_file = "Identifier", other_file = "IdentifierSecondary" }`のように、同一ファイル内シンボル・外部シンボルで色分けするハイライトグループを指定できます。
* **`jump_mode`** (string) - ジャンプの表示方法設定。`"current"`（現在ウィンドウに開く）, `"split"`（水平分割で開く）, `"vsplit"`（垂直分割）, `"tab"`（新規タブ）から選択。デフォルトは`"current"`。また、ジャンプ時にソースファイルに一時的なハイライトを付与するか（直近ジャンプ位置を目立たせる）等も設定可能です。
* **`auto_close`** (boolean) - ジャンプ操作した際にパネルを自動で閉じるかどうか。デフォルト`false`（閉じない）。`true`の場合、ユーザーが`e`キーでコードに飛んだらその時点でパネルを閉じます（軽量な挙動を好むユーザ向け）。
* **`log_level`** (string/number) - ログ出力レベル。デフォルトはエラーのみ。`"debug"`にするとLSP応答の中身や各処理の所要時間をメッセージエリアやログファイルに出力します。トラブルシューティング用途。

上記の他、プラグイン自体のオン/オフ（例えば特定ファイルタイプで無効化する設定）や、使用するLSPクライアントの選択（マルチサーバ環境でどの言語サーバにクエリを投げるか）といった設定も考慮します。基本的にはシンプルなデフォルトで動作し、必要なユーザーのみ設定を調整できるようにします。

# 受け入れ基準

本プラグインの実装完了後、受け入れテストを通じて以下の基準を満たしていることを確認します。

* **機能テスト**:

  * *ツリー表示*: 対応言語それぞれで、シンボルのIncoming/Outgoing呼び出し階層が正しく取得・表示されること。例えばJavaのメソッドに対して呼び出し元クラス一覧がツリー表示され、Rustの関数でも同様に動作することを各言語別に確認します。ノードの表記形式が「アイコン 関数名 — クラス名」と要件通りであること。
  * *展開/折り畳み*: ツリー上で`o`キーによるノード展開・折り畳みが正しく機能し、階層を深く辿れること。子ノード取得が行われる際に遅延なく（できれば瞬時に）表示更新されること。
  * *ジャンプ*: `e`キーで正しく該当シンボルの定義箇所や呼び出し箇所にエディタがジャンプすること。ジャンプ先ファイル・位置がLSPの返す位置情報と合致していること。ジャンプ後にパネルが予期通りの挙動（閉じずに残る/閉じる設定の場合は閉じる）をすること。
  * *リフレッシュ*: `r`キーで現在のツリーが再取得・更新されること。例えばテスト用にコードを編集し呼び出し関係を変えてからリフレッシュし、新しい関係が反映されることを確認します。
  * *フィルタ*: テストコード除外フィルタがデフォルトで効いていることを確認します。テスト用の関数を呼び出す関係を作ってもツリーに出現しないこと、設定でフィルタをOFFにすると出現することをテストします。
  * *履歴*: 複数の異なるシンボルでツリーを開いた後、`h`キーで過去のツリーに戻れること、さらに`l`キーで進めることを確認します。20件以上連続でツリーを開いた場合に古い履歴が削除され、新しい履歴が保持されていること（メモリリーク等ないこと）を確認します。
  * *UI/キー操作*: 画面下部にパネルが開き、想定したキーバインドが機能すること。`q`キーでパネルが閉じること。矢印キーや`j/k`でカーソル移動しノード選択できること。画面リサイズや他ウィンドウとの同時操作でもレイアウトが乱れないこと。

* **性能テスト**:

  * *初回表示時間*: 各対応言語の中規模プロジェクトで、適度に呼び出し関係のある関数を選択し、コマンド実行からツリー描画完了までの時間を計測します。平均して300ms以内、遅くとも500ms未満であること（ネットワーク越しのLSPサーバ等特殊ケースは除く）。可能なら自動計測（ログにタイムスタンプ出力）し、複数回測定して安定性も確認します。
  * *ノード展開時間*: 既にデータ取得済みのノードを展開/折り畳みする操作を100回程度連続で行い、体感的に遅延がないことを確認します。内部的にも処理時間がほぼ0に近いこと（目標20ms以内）をログなどで確認します。未取得ノードの初回展開も、LSP応答時間によりますが極端に遅くならないこと（例えば子が10個程度なら50\~100ms程度で処理される等）をテストします。
  * *メモリ/リソース*: 大規模なツリー（ノード数1000以上など）を表示してもNeovimがフリーズしたりメモリ不足にならないこと。Luaメモリ使用量をプロファイルし、履歴20件保持時でも許容範囲（数十MB以下）であること。不要になったデータがきちんとGCされていること。

* **互換性テスト**:

  * *異なる環境*: Windows, Linux, macOSの各OSで基本機能が動作することを確認します（可能ならCIで自動テスト）。Neovim 0.10.0および将来の0.11など最新版でも問題なく動作すること。依存するplenary.nvimやnvim-web-deviconsがインストールされていない状態で適切にエラーを出すこと、インストールされていれば正常に機能すること。
  * *LSPサーバ差異*: 言語ごとに微妙に異なるLSP実装でも破綻しないことを確認します。例えば言語AではincomingCallsが未実装の場合にエラーメッセージを表示してFallbackし、アウトラインのみ表示する等のハンドリングができているか。RustなどでcallHierarchyが不安定との報告があれば例外処理が入っているか。
  * *他プラグインとの共存*: 代表的なステータスラインプラグインやウィンドウ管理プラグインと一緒に使って表示が乱れないこと、キー衝突が発生しないことを検証します。他のLSP関連プラグイン（例：navigator.nvim等）と同時にロードした際にも、本プラグインの機能が利用可能なこと（ハンドラの二重定義等でエラーにならないか）を確認します。

* **コード品質/その他**:

  * *コードレビュー*: 実装コードがモジュール別に適切に分離され、可読性・保守性が高いこと。グローバル変数汚染がないこと、Luaエラーが発生しうる箇所に十分なチェックがあることを確認します。
  * *ドキュメント*: ヘルプドキュメント（`doc/callhierarchy.txt`）やREADMEに、本設計の機能・使い方・設定方法が漏れなく記載されていること。ユーザーが利用開始するのに十分な情報が提供されているか確認します。
  * *ユーザビリティ*: 実際に本プラグインを利用して開発してみて、動作が直感的であるか、不要な操作を強いられないか、UIの表示がわかりやすいかを評価します。必要であればメッセージ文言やデフォルト設定の調整を行います。

以上の基準を全て満たしたと判断できれば、本プラグインは受け入れ可能（リリース可能）となります。さらに、実際のユーザーからのフィードバックも踏まえて微調整を行い、継続的な改善を図っていきます。
